1、构造函数：给对应的对象进行初始化

2、反编译的命令：javap -c -l -private 类名

3、构造代码块：给所有的对象进行统一的初始化

其格式为：{}

4、局部代码块

5、静态代码块

6、this关键字

7、在一个有参数的构造方法中使用this()表示调用无参的构造函数。

8、static 修饰成员变量和函数

9、可以使用类名的方式访问

10、static修饰函数

11、单例设计模式

12、模式：解决一类问题的固定步骤。

13、23种设计模式：单例设计模式，模板设计模式，

14、保证内存中只有一个对象。私有化构造函数，

15、继承，父类的构造函数是不会被继承的。

16、在子类的构造方法种调用父类的构造函数用于初始化从父类继承过来的成员。

17、super必须是第一个语句。

18、方法的重写，必须有继承的关系。子类的访问修饰符、返回值类型、抛出的异常类型要小于或者等于父类的。子类的访问修饰符要大于或者等于父类的。

19、instanceof关键字

20、abstract关键字

21、非抽象类继承抽象类的时候，必须实现该抽象类所有的抽象方法

22、抽象类的构造函数是为了给其子类用于初始化的。

23、抽象类不能用于创建对象。

24、abstract不能与private配合使用， 不能配合final使用。

25、abstract不能配合static使用，因为通过类名的方式来调用抽象方法是没有意义的。

26、值传递与地址传递

27、笔记：

1、java是单继承的，一个类最多只能有一个直接父类。
2、接口：接口也是一个特殊的类。
3、在接口中定义的成员变量都是属于常量的。
4、在接口的方法都是抽象的方法。
5、接口的作用：拓展功能，定义约束规范，程序的解耦（最重要的功能）。
6、接口与类之间的关系：该类必须实现该接口所有的方法
7、一个类可以实现多个接口。
8、接口跟接口之间是继承的关系。
9、多态，一个对象具有多个状态，必须存在继承或者实现的关系。
10、父类引用类型变量指向了子类的对象或者是接口引用类型变量指向了实现该接口的对象。
多态要注意的细节：

	1. 多态情况下，子父类存在着同名的成员变量时，默认会访问父类的成员变量。
	2. 多态情况下，子父类存在着同名的非静态函数时，默认是访问子类的成员函数。
	3. 多态情况下，子父类存在着同名的静态函数时，默认是访问父类的成员函数。
	4. 多态情况下，不能访问子类特有的成员。

总结： 多态情况下，子父类存在同名的成员时， 默认都会访问父类的成员.只有存在非静态的
同名函数时，才是访问子类的成员。

fianl关键字要注意的细节：
	1. final关键字修饰一个基本类型变量时，其值不能重复赋值。
	2. final修饰一个引用类型变量时，该变量不能重新指向新的对象。
	3. final修饰一个方法的时候，该方法不能被重写。
	4. final 修饰一个类的时候，该类不能 被继承。
	
	多态情况下，利用强制类型的方式访问子类的成员。
	接口中定义的方法都是抽象的。

内部类：外部类$内部类
成员内部类的访问方法：
内部类的好处就是其可以直接访问外部类所有的成员。
局部内部类：在一个方法内部定义的类。
匿名内部类
- java中的异常机制
  - 运行时异常
  - 编译时异常



异常的处理方式：
方式一：捕获处理的格式

java编译器:
1、对java编译器来说，出现了废话，就会报错。

异常：
1、异常处理2：抛出异常
2、throw与throws的区别
3、运行时异常
4、编译时异常

包：
1、相当于windows中的一个文件夹的概念
2、决解类名重复的问题
3、方便软件版本的发布
4、package aa;为该类添加一个包名
5、完整类名为包名加类名。javac -d 
6、有了包以后，类与类之间的访问问题。
7、import 包名.类名
8、java.lang包的类jvm会自动导入，不需要手动导入
9、public protected default private 
10、打jar包，作用是方便用户使用。
11、一个jar文件就是一个压缩文件，就是把很多个class文件压缩成一个压缩文件。

随机数类

集合：
1、是可以存储任意对象数据的容器
2、其的长度是动态扩展的
3、数组也是一种容器
4、collection是单例集合类的根接口

collection类（）：
1、迭代器，遍历集合中的元素，iterator
2、用于捉取集合的元素
3、实现了list接口的集合具有有序，元素可重复的特点。
4、实现了list接口的集合具有无序，元素无重复的特点。
5、有序：元素添加的位置与存储的顺序一致
6、list接口特有的方法
7、listiterater接口特有的方法是操作索引值的。
8、按下F2可以显示该函数的具体信息。
9、迭代器在迭代的过程中要注意的问题：在遍历的时候不允许使用集合对象来改变集合对象的元素个数
10、什么叫迭代的过程：it.next()  aa = 12 it.next()
11、list接口的实现类
	arrylist：应用场景：查询多，增删少的情况，内部使用数组实现
	linkedlist：内部使用链表实现
	vector

12、神书：java编程思想
13、java核心技术
14、迭代器是集合中通用的遍历方法
15、java中在重写equals方法的时候同时要重写hashcode方法
16、实现了set接口的类具有的特点：无序、元素不重复
17、hashset的存储原理
18、什么是hash表，可以理解为一个简单的表格
19、hashset底层使用了哈希表，存取的速度快
20、alt + / 内容补全
21、string类重写的hashcode方法得到的数字是根据当前字符串的内容计算出来的。
22、treeset类
	如果元素不具备自然特性的特性，则需要实现compare接口中的compareTo方法，该方法不用我们手动调用
	底层使用的是红黑树的数据结构来实现的。
	红黑树的规则：左小右大，当三个节点构不成二叉树的时候，则需要调整二叉树的状态
23、创建一个比较器对象，当同时都有的时候，优先使用比较器的，推荐使用比较器的方法。
24、字符串的比较规则：
25、泛型：jdk1.5后出现的，可以有效避免无谓的强制类型转换
26、泛型中没有多态的概念
27、自定义的泛型
28、基本数据类型与之对应的包装类型
19、函数自定义泛型
20、自定义泛型类
21、静态的方法不能使用在类上声明的自定义泛型
22、自定义泛型使用的很多
23、泛型接口：在实现该接口的时候，类型被确定，泛型接口的使用非常多。
24、泛型在java中也是一个比较重要的概念
25、泛型的上下限
26、泛型的通配符：？，其一般不会单独使用，用于泛型的上下限
27、? super Integer表示只能接收Integer或者Integer的父类，这个表示是下限
28、? extends Integer表示的是上限
29、存储成对存在的数据。那么就要使用双列集合，其存储的数据都是以键值对的形式存在的
	key:不能重复
	value:可以重复
	hashmap:
	treemap:
30、map的迭代器
	keySet返回的是一个set集合，保存的只有键值
31、hashmap：底层也是维护了一个哈希表，是根据键值的哈希码来确定位置的
32、hashmap的存储原理
33、treeset的实现原理：也是通过红黑树来实现的
34、集合类的一些工具类
35、集合转数组，数组转集合
36、jdk1.5的新特性：静态导入
37、静态导入仅对于一个类的静态成员起作用
38、使用了泛型可以不使用强制类型的转换了
39、增强for循环 foreach语言，实现了Iterable,其底层还是通过获取迭代器来实现的
40、可变参数，可变参数其实就是一个数组
41、可变参数必须要位于形参列表中的最后一个位置

42、自动装箱与自动拆箱

	自动装箱：自动把基本数据类型转换成引用数据类型
	自动拆箱：自动把引用数据类型类型转换成基本数据
43、枚举类，其也是一个类，是一个特殊的类
等同于public static final Direction UP = new Direction();
44、枚举值其实就是一个当前枚举类的对象