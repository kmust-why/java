1、构造函数：给对应的对象进行初始化

2、反编译的命令：javap -c -l -private 类名

3、构造代码块：给所有的对象进行统一的初始化

其格式为：{}

4、局部代码块

5、静态代码块

6、this关键字

7、在一个有参数的构造方法中使用this()表示调用无参的构造函数。

8、static 修饰成员变量和函数

9、可以使用类名的方式访问

10、static修饰函数

11、单例设计模式

12、模式：解决一类问题的固定步骤。

13、23种设计模式：单例设计模式，模板设计模式，

14、保证内存中只有一个对象。私有化构造函数，

15、继承，父类的构造函数是不会被继承的。

16、在子类的构造方法种调用父类的构造函数用于初始化从父类继承过来的成员。

17、super必须是第一个语句。

18、方法的重写，必须有继承的关系。子类的访问修饰符、返回值类型、抛出的异常类型要小于或者等于父类的。子类的访问修饰符要大于或者等于父类的。

19、instanceof关键字

20、abstract关键字

21、非抽象类继承抽象类的时候，必须实现该抽象类所有的抽象方法

22、抽象类的构造函数是为了给其子类用于初始化的。

23、抽象类不能用于创建对象。

24、abstract不能与private配合使用， 不能配合final使用。

25、abstract不能配合static使用，因为通过类名的方式来调用抽象方法是没有意义的。

26、值传递与地址传递

27、笔记：

1、java是单继承的，一个类最多只能有一个直接父类。
2、接口：接口也是一个特殊的类。
3、在接口中定义的成员变量都是属于常量的。
4、在接口的方法都是抽象的方法。
5、接口的作用：拓展功能，定义约束规范，程序的解耦（最重要的功能）。
6、接口与类之间的关系：该类必须实现该接口所有的方法
7、一个类可以实现多个接口。
8、接口跟接口之间是继承的关系。
9、多态，一个对象具有多个状态，必须存在继承或者实现的关系。
10、父类引用类型变量指向了子类的对象或者是接口引用类型变量指向了实现该接口的对象。
多态要注意的细节：

	1. 多态情况下，子父类存在着同名的成员变量时，默认会访问父类的成员变量。
	2. 多态情况下，子父类存在着同名的非静态函数时，默认是访问子类的成员函数。
	3. 多态情况下，子父类存在着同名的静态函数时，默认是访问父类的成员函数。
	4. 多态情况下，不能访问子类特有的成员。

总结： 多态情况下，子父类存在同名的成员时， 默认都会访问父类的成员.只有存在非静态的
同名函数时，才是访问子类的成员。

fianl关键字要注意的细节：
	1. final关键字修饰一个基本类型变量时，其值不能重复赋值。
	2. final修饰一个引用类型变量时，该变量不能重新指向新的对象。
	3. final修饰一个方法的时候，该方法不能被重写。
	4. final 修饰一个类的时候，该类不能 被继承。
	
	多态情况下，利用强制类型的方式访问子类的成员。
	接口中定义的方法都是抽象的。

内部类：外部类$内部类
成员内部类的访问方法：
内部类的好处就是其可以直接访问外部类所有的成员。
局部内部类：在一个方法内部定义的类。
匿名内部类
- java中的异常机制
  - 运行时异常
  - 编译时异常



异常的处理方式：
方式一：捕获处理的格式

java编译器:
1、对java编译器来说，出现了废话，就会报错。

异常：
1、异常处理2：抛出异常
2、throw与throws的区别
3、运行时异常
4、编译时异常

包：
1、相当于windows中的一个文件夹的概念
2、决解类名重复的问题
3、方便软件版本的发布
4、package aa;为该类添加一个包名
5、完整类名为包名加类名。javac -d 
6、有了包以后，类与类之间的访问问题。
7、import 包名.类名
8、java.lang包的类jvm会自动导入，不需要手动导入
9、public protected default private 
10、打jar包，作用是方便用户使用。
11、一个jar文件就是一个压缩文件，就是把很多个class文件压缩成一个压缩文件。

随机数类

集合：
1、是可以存储任意对象数据的容器
2、其的长度是动态扩展的
3、数组也是一种容器
4、collection是单例集合类的根接口

collection类（）：
1、迭代器，遍历集合中的元素，iterator
2、用于捉取集合的元素
3、实现了list接口的集合具有有序，元素可重复的特点。
4、实现了list接口的集合具有无序，元素无重复的特点。
5、有序：元素添加的位置与存储的顺序一致
6、list接口特有的方法
7、listiterater接口特有的方法是操作索引值的。
8、按下F2可以显示该函数的具体信息。
9、迭代器在迭代的过程中要注意的问题：在遍历的时候不允许使用集合对象来改变集合对象的元素个数
10、什么叫迭代的过程：it.next()  aa = 12 it.next()
11、list接口的实现类
	arrylist：应用场景：查询多，增删少的情况，内部使用数组实现
	linkedlist：内部使用链表实现
	vector

12、神书：java编程思想
13、java核心技术
14、迭代器是集合中通用的遍历方法
15、java中在重写equals方法的时候同时要重写hashcode方法
16、实现了set接口的类具有的特点：无序、元素不重复
17、hashset的存储原理
18、什么是hash表，可以理解为一个简单的表格
19、hashset底层使用了哈希表，存取的速度快
20、alt + / 内容补全
21、string类重写的hashcode方法得到的数字是根据当前字符串的内容计算出来的。
22、treeset类
	如果元素不具备自然特性的特性，则需要实现compare接口中的compareTo方法，该方法不用我们手动调用
	底层使用的是红黑树的数据结构来实现的。
	红黑树的规则：左小右大，当三个节点构不成二叉树的时候，则需要调整二叉树的状态
23、创建一个比较器对象，当同时都有的时候，优先使用比较器的，推荐使用比较器的方法。
24、字符串的比较规则：
25、泛型：jdk1.5后出现的，可以有效避免无谓的强制类型转换
26、泛型中没有多态的概念
27、自定义的泛型
28、基本数据类型与之对应的包装类型
19、函数自定义泛型
20、自定义泛型类
21、静态的方法不能使用在类上声明的自定义泛型
22、自定义泛型使用的很多
23、泛型接口：在实现该接口的时候，类型被确定，泛型接口的使用非常多。
24、泛型在java中也是一个比较重要的概念
25、泛型的上下限
26、泛型的通配符：？，其一般不会单独使用，用于泛型的上下限
27、? super Integer表示只能接收Integer或者Integer的父类，这个表示是下限
28、? extends Integer表示的是上限
29、存储成对存在的数据。那么就要使用双列集合，其存储的数据都是以键值对的形式存在的
	key:不能重复
	value:可以重复
	hashmap:
	treemap:
30、map的迭代器
	keySet返回的是一个set集合，保存的只有键值
31、hashmap：底层也是维护了一个哈希表，是根据键值的哈希码来确定位置的
32、hashmap的存储原理
33、treeset的实现原理：也是通过红黑树来实现的
34、集合类的一些工具类
35、集合转数组，数组转集合
36、jdk1.5的新特性：静态导入
37、静态导入仅对于一个类的静态成员起作用
38、使用了泛型可以不使用强制类型的转换了
39、增强for循环 foreach语言，实现了Iterable,其底层还是通过获取迭代器来实现的
40、可变参数，可变参数其实就是一个数组
41、可变参数必须要位于形参列表中的最后一个位置

42、自动装箱与自动拆箱

	自动装箱：自动把基本数据类型转换成引用数据类型
	自动拆箱：自动把引用数据类型类型转换成基本数据
43、枚举类，其也是一个类，是一个特殊的类
等同于public static final Direction UP = new Direction();
44、枚举值其实就是一个当前枚举类的对象



string类的创建方法：
1、比较的是引用
2、string类已经重写了object类的equals方法，比较的是其的内容。
3、string类的构造方法
4、使用一个byte数组构建一个数组
5、这些类我们不用记住，会用就行，不要死记硬背。
6、获取字符串的长度
7、字符串的equal方法一般都是常量放到前面，变量放到后面。可以有效避免空指针异常的情况。
8、字符串对象没有提供增加、删除、修改的方法。
9、字符串的内容一旦创建，则不允许改变，如果一旦改变，则会创建一个新的字符串对象
10、如果需要修改一个字符串的内容，则建议使用字符串缓冲区类。
11、字符串缓冲区类：是存储字符的集合容器，当其的容量不够的时候，自动增加多少
12、stringbuffer底层维护了一个字符数组
13、什么时候使用字符串的缓冲类，需要频繁的对字符串操作。

stringbuilder字符串缓冲类（线程不安全）与stringbuffer类（线程安全）的区别
1、线程安全与不安全的问题
2、多个人同时运行一份代码
3、推荐使用stringbuilder字符串缓冲类

system类：
1、其是一个系统类，主要用于获取系统的参数信息。

runtime类：用于描述应用程序的运行状态

date日期类：
Calendar类
日期格式化类
math类
正则表达式：
1、用于操作字符串的一些规则
2、预定义字符
	. 任何字符（与行结束符可能匹配也可能不匹配） 
	\d 数字：[0-9] 
	\D 非数字： [^0-9] 
	\s 空白字符：[ \t\n\x0B\f\r] 
	\S 非空白字符：[^\s] 
	\w 单词字符：[a-zA-Z_0-9] 
	\W 非单词字符：[^\w] 
3、正则表达式对字符串的常见操作：
	匹配、切割、替换、查找
4、组号
5、正则表达式对象：pattern(查找)、matcher(匹配器对象)
6、匹配器常用的方法：
7、单词边界匹配器

file类（IO操作）：解决设备与设备之间的数据传输问题，比如内存到---硬盘
1、IO的使用比较多
2、目录分隔符
3、绝对路径与相对路径，绝对路径也是特殊的相对路径

IO流技术：（操作文件内容数据）
1、IO流的分类：
	流向（输入流与输出流）
	处理的单元（字节流，对读取的数据不做任何的处理、字符流=字节流+解码）
2、输入字节流（IO类比集合类要简单）
3、ctrl+t可以查看一个类的继承体系
4、推荐使用循环配合缓冲数组的方式读取文件
5、在文件的操作中资源的释放非常重要
6、文件拷贝

IO异常处理：

缓冲流：
1、缓冲输入字节流：作用是提高我们读取文件数据的效率，其来内部维护了一个8kb的一个字节数组
2、其的read方法读取的数据是从内部维护的位于内存的buffer数组中获取数据的
3、缓冲输出字节流
4、字节流是不具备编码或者解码的功能的

字符流：
1、读取的数据是以字符为单位的，会把读取到的字节数据转换成我们看得懂的字符
2、输出字符流，不关闭的话，不能写入数据。
3、如果操作的是文本数据，这个时候就应该使用字符流
4、如果操作的是非文本数据，这个时候应该使用字节流。图片、视频、音频等。

字符流的缓冲流：
1、bufferedreader，该类的出现是为了提高读取文件字符数据的效率
码表：
1、字符 码值
2、中文默认的码表为gbk

字节流和字符流在IO操作中非常重要：
1、装饰者设计模式：增强一个类的功能
2、增强一个类的功能，可以通过继承一个类来实现，让增强与被增强类有一个共同父类或者父接口
3、在同一个包中不能出现同名的类名
4、装饰者设计模式的好处：利用多态达到了类与类之间可以互相的装饰

重构：
1、选中相应的代码，然后选择重构，扩展的方法。

文件的合并：
1、序列流：用于合并多个流，该序列流也是没有读写文件的能力的
2、对象的输出流对象，该类重要是用于把对象数据写入到文件上去。
3、只有实现了Serializable接口的对象才可以写入文件中，其没有任何的属性和方法，这个接口叫做标志接口，只是起一个标识的作用
4、把对象写到文件里面，叫做对象的序列化。
5、对象的反序列化就是把读取硬盘中的对象到内存中
6、对象的输入流对象：读取硬盘中的对象到内存中
7、对象的反序列的时候创建对象是不会调用构造方法的。对象的创建需要.class文件
8、把对象写到文件上的时候，除了记录对象的一些信息外，还记录了class的版本号
9、在反序列话的，jvm会使用本地class文件算出一个id号，并与文件记录的id号进行对比，如果不一致，则反序列化失败
10、如果一个类内部维护了一个对象属性，则该对象属性也是需要实现Serializable接口的

配置文件类：
1、properties,非常重要，很多软件都是依赖配置文件来工作的。其就是一个容器
2、作用：可以生成配置文件，也可以读取配置文件
3、属于map集合体系的
4、创建一个配置文件
5、如果输入非字符文件，则会转换出错，建议使用字符流
6、读去配置文件到properties使用load方法
7、如果修改了properties里面的文件，一定要重新生成一个配置文件。

printfStream类：
1、打印流可以打印任意类型的数据，其会先把数据转成字符串然后再打印出去。
2、标准输出流（默认为控制台）与标准的输入流（默认为键盘）
3、编码与解码
4、编码就是把看得懂的变为看不懂的
5、Unicode就是一个规范，也就是一个标准。
6、UTF-8就是实现了Unicode规范的编码，一个英文占一个字节，一个
中文占3个字节
7、UTF-16：全部字符都占2个字节
8、出现了乱码都可以还原成功吗？
9、我们一般都会让编码与解码都使用同一种码表。
10、编码的时候使用unicode，默认使用的是utf-16编码

转换流：
1、读取控制台的数据
2、如何把字节流转换成字符流
3、把输出字节流转换成输出字符流
4、需要注意的是没有字符流转换成字节流
5、可以指定任意类型的码表
6、递归的算法：函数自己调用自己，在一个方法的内部调用方法的本身


线程：
1、正在运行的程序叫做一个进程
2、windows号称是多任务的操作系统，宏观上是多个程序并行运行
3、线程负责代码的运行，对应了一个个函数，线程是进程中的一个代码执行路径
4、线程在做CPU资源的争夺战
5、多线程：在一个进程中有多个线程在执行不同的任务代码
6、任何一个java程序运行的时候，jvm都会为该应用程序创建一个主线程，主线程就是
把main方法的代码执行完毕
7、一个java应用程序在运行的时候至少有几个线程？
2个：一个是主线程、一个是垃圾回收线程
8、多线程的好处：
	解决在一个进程中同时执行多个任务代码的问题
	提高了资源的利用率，效率并没有提高
9、多线程的缺点：
	增加了CPU的负担
	降低了一个进程中线程的执行概率
	引发了线程安全问题
	引发了死锁现象
10、new 线程() 创建---->调用start方法（可运行状态）--->进入运行状态
11、线程具有五种状态：创建、可运行状态、运行状态、消亡状态、临时阻塞状态
12、线程常用的方法
13、默认的优先级为5，优先级越高，则得到CPU执行的概率越大
14、线程安全问题
15、出现线程安全问题的根本原因：
	存在多线程
	多个线程操作了共享的资源，多个线程共享这同一个资源，操作共享资源的代码有多句
16、线程安全问题的解决方案；
	使用同步代码块：需要一个锁对象，锁对象可以是任意的对象，任意的对象都隐藏了一个状态，也是一个标志，已可以是一个成员变量，
	在一个时间片内只允许一个线程允许，锁对象必须是多个线程共享的一个对象。锁对象必须是唯一的。
	线程调用sleep方法是不会释放锁对象的
	只有线程会出现线程安全问题的时候才会使用java的同步机制（同步代码块和同步函数）
	使用同步函数

17、使用synchronized修饰的函数就称为同步函数
18、非静态同步函数的锁对象是this对象,
19、静态同步函数的锁对象是当前方法所属的类的class文件对象
20、同步函数的锁对象是固定的，无法更改。
21、推荐使用同步代码块：
	同步代码块的锁对象可以由我们指定，同步函数的锁对象是固定
	同步代码块可以随意指定同步的代码，同步函数必须是整个函数都同步，代码不灵活。

java同步机制解决了线程安全问题，但是同时也引发了死锁现象（互相等待的情况）
1、	如何解决死锁问题：无法解决，只能尽量避免死锁现象
2、死锁现象出现的根本原因：
	存在多线程
	多个线程共享多个资源
3、创建线程的另外一种方法
	自定义一个类去实现runnable接口，
	把自定义线程的任务定义在run方法中
	创建runnable实现类的对象，并调用start方法开启线程
	创建thread对象，并且把runnable实现类的对象作为参数传入进去
	runnable实现类对象并不是一个线程对象，只不过是实现了runnable接口的类而已。
4、为什么要把runnable实现类对象传入给thread对象呢？
	把runnable实现类的run方法作为了线程的任务代码去执行了
5、推荐使用第二中方法，因为java是单继承的，第二种更加灵活。

守护线程：也成为后台线程
1、当一个java应用程序只剩下守护线程的时候，那么守护线程会马上结束
2、守护线程的应用场景：
	新的软件版本下载
3、所有的线程默认都不是守护线程
4、join:线程让步函数，如果当前线程执行了join线程，那么当前线程
就会让步给新加入的线程完成任务，之后再去完成自己的任务

线程通信：
1、当一个线程完成了一个任务的时候，需要通知另外一个线程去处理其他的事情。
2、 消费者与生产者
3、价格错乱：这是一个线程安全问题
4、保证生产一个就消费一个
5、线程通信的方法：wait()和notify()
6、执行了wait方法的线程会处于等待状态，会让该线程进入以锁对象建立的线程池中等待
7、唤醒等待的线程
8、线程通信的方法来自于object类
9、这些方法必须要在同步代码块（或者同步函数）中调用，必须由锁对象来调用
10、如何知道一个产品是否已经生产完毕
11、一个线程如果执行了wait方法，那么该线程会进入以锁对象作为标识的一个线程池中等待
12、一个线程执行了notify方法，表示唤醒以锁对象作为标识符的线程池中的等待线程中的其中一个，策略
为先等待的先被唤醒
13、一个线程执行了wait方法，会释放锁对象的
14、notifyall表示唤醒所有的线程，只会唤醒相应锁对象的线程池中的对象
15、线程停止：即一个线程的任务函数执行完毕即可，强制清除一个线程的wait、sleep,可以指定唤醒那个线程，而notify不能指定
16、停止线程的要点：

	停止一个线程一般都会配合一个变量去控制
	如果停止的是一个处于等待状态下的线程，那么变量需要配合这个interupt方法去使用才可以停止